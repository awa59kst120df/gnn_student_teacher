import typing as t
import logging

import numpy as np

from gnn_student_teacher.util import NULL_LOGGER
from gnn_student_teacher.data.structures import AbstractStudentResult
from gnn_student_teacher.data.structures import MockStudentResult


STUDENT_VARIANTS = {
    'ref': '',
    'exp': ''
}


# == BASE CLASSES ==

class AbstractStudentModel:

    def __init__(self,
                 name: str,
                 variant: str,
                 **kwargs):
        self.base_name = name
        self.variant = variant
        self.full_name = f'{name}_{variant}'

    def predict_single(self,
                       node_attributes: np.ndarray,
                       edge_attributes: np.ndarray,
                       edge_indices: np.ndarray
                       ) -> t.Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        This method should take a generic version of a single dataset element as input and then return
        a generic format for the produced output value as well as the node and edge importances.
        "Generic format" means that the input / output of the method should not be special datatypes such
        as keras or pytorch tensor instances, but just plain numpy arrays.

        :param node_attributes: Array of shape (V, N) where V is the number of nodes in the graph
            and N is the number of features per node
        :param edge_attributes: Array of shape (E, M) where E is the number of edges in the graph and
            M is the number of features per edge
        :param edge_indices: Array of shape (E, 2) containing integer node indices. Can be considered as
            a list of 2-tuples which each define an edge.

        :returns: A tuple of three values:
            - output: Array of shape (O, ) where O is the number of outputs generated by the model. This is
              usually equal to 1 for regression and for classification tasks the number of classes.
            - node_importances: Array of shape (N, K) where K is the number of importance / explanation
              channels employed by the model
            - edge_importances: Array of shape (E, K)
        """
        raise NotImplementedError()


class StudentTemplate(object):

    def __init__(self,
                 student_class: type,
                 student_name: str,
                 **kwargs):

        self.student_class = student_class
        self.student_name = student_name
        self.kwargs = kwargs

    def instantiate(self,
                    variant: str,
                    additional_kwargs: dict = {}
                    ) -> AbstractStudentModel:

        kwargs = {**self.kwargs, **additional_kwargs}
        return self.student_class(
            name=self.student_name,
            variant=variant,
            **kwargs
        )


class AbstractStudentTrainer:

    def __init__(self,
                 model: AbstractStudentModel,
                 dataset: t.Any,
                 logger: logging.Logger = NULL_LOGGER,
                 result_class: type = MockStudentResult,
                 **kwargs):
        self.model = model
        self.dataset = dataset
        self.result_class = result_class
        self.logger = logger

        self._kwargs: t.Optional[dict] = kwargs
        self._fit_kwargs: t.Optional[dict] = None

    def fit(self, **kwargs) -> t.Dict[str, dict]:
        self._fit_kwargs = kwargs

        result = self.result_class()
        self.__fit__(result, **kwargs)

        result.validate()
        return result

    # -- TO BE IMPLEMENTED --

    def __fit__(self,
                result: AbstractStudentResult,
                *kwargs):
        raise NotImplementedError()
